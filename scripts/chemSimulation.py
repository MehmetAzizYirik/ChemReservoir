"""
Functions for the stochastic simulation and ridge regression
for the MOD-based reservoir computing network.

@author Mehmet Aziz Yirik
"""

import sys
from mod import *
import mod as mod
import mod.stochsim as stoch
import seaborn as sns
import colorcet as cc
from timeit import default_timer as timer
from scipy.signal import find_peaks
from scipy.interpolate import pchip
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import random, math
import importlib, sys, gc, inspect
from mod.libpymod import CausalityEdgeAction, CausalityInputAction, CausalityOutputAction
from tensorflow.python.ops.numpy_ops.np_dtypes import float32


class simFunc:
    def __init__(self, arguments):
        self.colors=None #color set to be defined for the plotting.
        self.concentrations=None #molecule concentrations from traces.
        self.uniqueRuleIDs=None #the list of unique reaction rule ids.
        self.epsilonTimeArray=None #time array generated by the input epsilon value based on the min max time in traces.
        self.iRateSeries=None #the input flow array, or irate array.
        self.outRate=float(arguments[1]) #output rate defined by the user for the simulation.
        self.scalingRate=float(arguments[2]) #scaling rates for scaling the input flow, output and reaction rates.
        self.inputGraphs=None #input graphs are the user defined input molecules.
        self.seed=int(arguments[0]) #User defined seed for the random module.
        self.initialMoleculeLabels=[] #initial molecule label defined by input graphs.
        self.simulationResult=None #mod stochsim result.
        self.traces=None #mod stochsim traces.
        self.iRate={} #input flow array specified molecules.
        self.experimentalTimes= None #experimental times from the experiment.
        self.moleculeLabels=[] #updated molecule labels, after the simulation.
        self.moleculeLabelsNotPlotted=None #molecules, not to be plotted.
        self.moleculeFlow=[]
        self.inputFlowTimes=[]
        self.outFlowMolecule=None
        self.totalRunTime=None
        self.iterationInputFlows=None
        self.numberOfMolecules=0
        self.numberOfReactions=0
        self.reactionRateScale=int(arguments[4])
        self.reactionRatesList=arguments[5].split(',')
        self.reactionRatesDict=dict()
        self.Food1=None

    def initializeIRate(self):
        """
        Initialize the iRate for the initial molecules.
        """

        for molecule in self.initializedMolecules:
            self.iRate[molecule]:None
            
    def generateRates(self, flows, rStart=0, rEnd=0):
        """
        Generating the input and reactions rates randomly for the given
        parameters.

        @param rStart int reaction rate lower limit
        @param rEnd   int reaction rate upper limit
        """
        
        self.getExperimentalTimeArray()
        self.scalingRates(flows)

    def getExperimentalTimeArray(self, experimentalTimeArray=None ):
        """
        Defining the experimental time array. If it is not given by user, the
        time range it defined by default based on total run time.
        
        @param  experimentalTime    float or int array  user defined experimental time array
        """

        self.experimentalTimes= experimentalTimeArray if experimentalTimeArray else range(self.totalRunTime)
        
    def scalingRates(self, flows):
        """
        Scaling the input flow rates.
        """
        scaledFlows=np.empty_like(flows)
        scaledFlows=flows*self.scalingRate
        self.iRateSeries=scaledFlows

    def interpolationSingle(self, time, iRateSeries):
        """
        Performing the interpolation for the trace time to detect the irate/ input flow.
        
        @param time     float   current trace time
        @param iRateSeries     list   input inflow rate values.
        """
        return np.interp(time, self.experimentalTimes, iRateSeries)
    
    def interpolation(self, time):
        """
        Performing the interpolation for the trace time to detect the irate/ input flow.
        
        @param time     float   current trace time

        Returns:
            float: interpolated value for the inflow.
        """
        value=self.interpolationSingle(time, self.iRateSeries)
        return value
        
    def iRateCallback(self, v):
        """
        Function for the stochastic simulation.

        @param v dg.vertex a vertex in the DG
        """
        if v.graph in self.iRate:
            return (self.iRate[v.graph], True)
        else:
            return (0, True)

    def oRate(self, v):
        """
        Simulation subfunction for the outflow amount.

        @param v dg.vertex a vertex in the DG

        Returns:
            tuple: (outflow, caching boolean)
        """
        return self.outRate, True

    def reactionRates(self, e):
        """
        Defining the reaction rates individually.

        @param e dg.edge an edge in the DG

        Returns:
            tuple: (reaction rate value, caching boolean)
        """
        rule = next(iter(e.rules))
        return (self.reactionRatesDict[rule], True)

    def onIterationBegin(self, time, i):
        """
        Simulation sub function for inflow values of each iteration.

        @param time     float   current trace time
        """
        if not self.inputFlowTimes:
            value = self.interpolation(time)
        elif (time - self.inputFlowTimes[-1]) >= 1:
            value = self.interpolation(time)
        else:
            return

        self.moleculeFlow.append(value)
        self.inputFlowTimes.append(time)
        self.iRate[self.Food1] = value

    def simulation(self, inputRules, inputGraphs, initialStates, traceIteration=0, traceTime=0):
        """
        Stochastic simulation function from MOD.

        @param traceIteration   int                     the number of iterations for trace
        @param traceTime        int                     the duration time for each iteration in trace
        """
        strat = rightPredicate[lambda d: all(g.vLabelCount("C") <= 6 for g in d.right)](
            (
                inputRules
            )
        )
        simulationResult = stoch.Simulator(
            graphDatabase=inputGraphs, labelSettings=LabelSettings(
    LabelType.Term, LabelRelation.Specialisation),
            expandNetwork=stoch.ExpandByStrategy(strat),
            initialState=initialStates,
            draw=stoch.DrawMassAction(
                inputRate=self.iRateCallback,
                reactionRate=self.reactionRates,
                outputRate=self.oRate
            )
        )

        simulationResult.onIterationBegin = self.onIterationBegin
        traces= simFunc.getTraces(self.totalRunTime, simulationResult)
        dg = mod.DG
        edgeUsed = set()
        for t in traces:
            if isinstance(t.action, mod.CausalityEdgeAction):
                edgeUsed.add(t.action.edge)
        dg = next(iter(edgeUsed)).dg
        p = mod.DGPrinter()
        p.withGraphImages = False
        p.pushEdgeColour(lambda e: "blue" if e in edgeUsed else "")
        del simulationResult
        dg.print(p)
        return traces

    @staticmethod
    def getTraces(totalRunTime, simulationResult):
        """
        Calling the EventTraces for the stochastic simulation.

        @param time     int     the duration time for the whole simulation
        """

        time = totalRunTime
        trace = simulationResult.simulate(time=time)
        return trace

    def printDG(self, traces):
        """
        Printing the derivation graph by highlighting the used chemical
        reactions.
        """
        dg = mod.DG
        edgeUsed = set()
        for t in traces:
            if isinstance(t.action, mod.CausalityEdgeAction):
                edgeUsed.add(t.action.edge)
        dg = next(iter(edgeUsed)).dg
        p = mod.DGPrinter()
        p.withGraphImages = False
        p.pushEdgeColour(lambda e: "blue" if e in edgeUsed else "")
        p.pushEdgeLabel(lambda e: "k={}".format(self.reactionRates(e)[0]))
        dg.print(p)
        '''
        for a in dg.graphDatabase:
            a.print()
        '''

    def printDGWithCounts(self):
        """
        Printing the derivation graph by highlighting the input flow and out flow.
        """
        cIn = {}
        cOut = {}
        cEdge = {}
        dg = None
        for t in self.traces:
            if isinstance(t.action, CausalityEdgeAction):
                if t.action.edge not in cEdge:
                    cEdge[t.action.edge] = 0
                    dg = t.action.edge.dg
                cEdge[t.action.edge] += 1
            elif isinstance(t.action, CausalityInputAction):
                if t.action.vertex not in cIn:
                    cIn[t.action.vertex] = 0
                    dg = t.action.vertex.dg
                cIn[t.action.vertex] += 1
            elif isinstance(t.action, CausalityOutputAction):
                if t.action.vertex not in cOut:
                    cOut[t.action.vertex] = 0
                    dg = t.action.vertex.dg
                cOut[t.action.vertex] += 1
            else:
                assert False
        if dg is None:
            assert False, "There are no events in the trace."
        assert dg.locked, "The DG must be locked, perhaps delete the simulator."
        self.numberOfMolecules=dg.numVertices
        self.numberOfReactions=dg.numEdges
        p = DGPrinter()
        p.pushVertexVisible(lambda v: v in cIn or v in cOut)
        p.pushEdgeVisible(lambda e: e in cEdge)
        p.pushVertexLabel(lambda v: "cIn={}, cOut={}".format(cIn.get(v, 0), cOut.get(v, 0)))
        p.pushEdgeLabel(lambda e: "c={}".format(cEdge.get(e, 0)))
        p.pushEdgeLabel(lambda e: "k={}".format(self.reactionRates(e)[0]))
        dg.print(p)
    
    def printDGWithAll(self):
        """
        Printing the derivation graph by highlighting the input flow, out flow,
        and the occurrences of the reactions.
        """

        del self.simulationResult
        cIn = {}
        cOut = {}
        cEdge = {}
        dg = None
        initState = self.traces.initialState
        endState = self.traces.initialState
        for t in self.traces:
            t.action.applyTo(endState)
            if isinstance(t.action, mod.CausalityEdgeAction):
                if t.action.edge not in cEdge:
                    cEdge[t.action.edge] = 0
                    dg = t.action.edge.dg
                cEdge[t.action.edge] += 1
            elif isinstance(t.action, mod.CausalityInputAction):
                if t.action.vertex not in cIn:
                    cIn[t.action.vertex] = 0
                    dg = t.action.vertex.dg
                cIn[t.action.vertex] += 1
            elif isinstance(t.action, mod.CausalityOutputAction):
                if t.action.vertex not in cOut:
                    cOut[t.action.vertex] = 0
                    dg = t.action.vertex.dg
                cOut[t.action.vertex] += 1
            else:
                assert False
        if dg is None:
            assert False, "There are no events in the trace."
        assert dg.locked, "The DG must be locked, perhaps delete the simulator."
        
        self.numberOfMolecules=dg.numVertices
        self.numberOfReactions=dg.numEdges

        p = DGPrinter()
        p.pushVertexColour(lambda v: "blue" if v in cIn or v in cOut else "gray")
        p.pushEdgeColour(lambda e: "blue" if e in cEdge else "gray")
        p.pushVertexLabel(lambda v: "i={}".format(initState[v]) if initState[v] != 0 else "")
        p.pushVertexLabel(lambda v: "cIn={}".format(cIn.get(v, 0)) if v in cIn else "")
        p.pushVertexLabel(lambda v: "cOut={}".format(cOut.get(v, 0)) if v in cOut else "")
        p.pushVertexLabel(lambda v: "e={}".format(endState[v]) if endState[v] != 0 else "")
        p.pushEdgeLabel(lambda e: "c={}".format(cEdge.get(e, 0)))  # should be there by definition
        p.pushEdgeLabel(lambda e: "k={}".format(self.reactionRates(e)[0]))
        dg.print(p)

    def getReactionFrequencies(self):
        """
        Get the reaction frequencies for the traces
        """
        reaction = {}
        tuple = None
        hyperEdge=None
        initState = self.traces.initialState
        endState = self.traces.initialState
        for t in self.traces:
            t.action.applyTo(endState)
            if isinstance(t.action, CausalityEdgeAction):
                hyperEdge=t.action.edge
                for rule in hyperEdge.rules:
                    tuple = (rule.name, t.time)
                    if tuple not in reaction:
                        reaction[tuple] = 0
                    reaction[tuple] += 1
        return reaction
        
    def getReactionFrequenciesDictionary(self):
        """
        Get the reaction frequencies for the traces as dictionary format.
        """
        timeWindows = self.generateTimeWindows()
        timeWindowsDict = {window: {} for window in timeWindows}
        hyperEdge=None
        initState = self.traces.initialState
        endState = self.traces.initialState
        for t in self.traces:
            t.action.applyTo(endState)
            if isinstance(t.action, CausalityEdgeAction):
                hyperEdge=t.action.edge
                for rule in hyperEdge.rules:
                    searchedTimeWindow = self.searchWindowTuple(t.time, timeWindows)
                    if rule.name in timeWindowsDict[searchedTimeWindow]:
                        timeWindowsDict[searchedTimeWindow][rule.name] += 1
                    else:
                        timeWindowsDict[searchedTimeWindow][rule.name] = 0
        return timeWindowsDict
        
    def getUniqueRuleIDs(self, timeWindowsDict):
        """
        Retriving the unique reaction rule ids information
        from the time windows dictionary of reactions.
        Time windows mean the epsilon define time ranges over the traces time
        """
        unique = set()
        for window in timeWindowsDict:
            for key in timeWindowsDict[window].keys():
                unique.add(key)
        return sorted(unique)
    
    def retrieveRuleFrequency(self, ruleNames, timeWindows, timeWindowsDict):
        """
        First calculating the average time for the time ranges, then
        for each reaction, assigning the reaction frequency information for that average time.
        
        @param ruleNames        str[]       unique list of rule names
        @param timeWindows      dict{(,)}   time windows defined based on epsilon value
        @param timeWindowsDict  dict{}      reaction frequencies stored as a dictionary
        """
        rule = None
        timeArray=[]
        index=0
        for window in timeWindows:
            timeArray.append(self.getAverageTime(window))
        data = np.zeros((len(timeArray), len(ruleNames)+1))
        data[:,0]=timeArray
        for window in timeWindows:
            for i in range(len(ruleNames)):
                rule = ruleNames[i]
                if rule in timeWindowsDict[window]:
                    index = np.where(data[:, 0] == self.getAverageTime(window))
                    data[index[0], i+1]=timeWindowsDict[window][rule]
        return data
    
    def reactionFrequenciesData(self):
        """
        Getting the reaction frequencies data both the frequencies
        and rule names as labels for plotting.
        """
        timeWindowsDict=self.getReactionFrequenciesDictionary()
        timeWindows=list(timeWindowsDict.keys())
        ruleNames = self.getUniqueRuleIDs(timeWindowsDict)
        reactionData = self.retrieveRuleFrequency(ruleNames,timeWindows, timeWindowsDict)
        return (reactionData, ruleNames)

    def getTimeWindowsConcentrations(self, originalTimeArray, averageTimesArray, timeWindows, originalConcentrations):
        """
        Get the concentrations for the time windows for each molecule.
        
        @param originalTimeArray int[] traces time array
        @param averageTimesArray int[] the average time for each epsilon time window
        @param timeWindows dict{(,)} time windows defined with the epsilon value
        @param originalConcentrations int[][] original concentrations over each traces
        """
        
        timeWindowsConcentrations = np.zeros((len(averageTimesArray), originalConcentrations.shape[1]+1))
        timeWindowsConcentrations[:,0]=averageTimesArray
        timeWindowsOccurences= {key: 0 for key in averageTimesArray}
        lengthOfTimeArray=len(originalTimeArray)
        numberOfConcentrations=originalConcentrations.shape[1]
        for i in range(lengthOfTimeArray):
            averageTimeForWindow = self.getAverageTime(self.searchWindowTuple(originalTimeArray[i], timeWindows))
            '''
            For each time in original check its time window and calculate the average time. Used for
            counting molecule counts in the time windows.
            '''
            index = np.where(timeWindowsConcentrations[:, 0] == averageTimeForWindow)
            timeWindowsOccurences[averageTimeForWindow]+=1
            for j in range(numberOfConcentrations):
                timeWindowsConcentrations[index, (j+1)]+=originalConcentrations[i, j]
            '''
            As we run through each time entry in the original simulation time array, we count the
            occurrences within the time windows and for each time summing the molecule counts.
            '''
        timeWindowsConcentrations=self.getNormalizedTimeWindowsConcentrations(averageTimesArray, timeWindowsConcentrations, timeWindowsOccurences)
        return timeWindowsConcentrations
        
    def getNormalizedTimeWindowsConcentrations(self, averageTimesArray, timeWindowsConcentrations, timeWindowsOccurences):
        """
        Getting the occurrences of each time windows as the dictionary, then getting the average concentration
        for each time window for unbiased results.
        
        @param averageTimesArray int[] the average time for each epsilon time window
        @param timeWindowsConcentrations int[][] concentration sum for each time window
        @param timeWindowsOccurences dict{} the occurrences of the traces in each time window
        """
        rows=timeWindowsConcentrations.shape[0]
        columns=timeWindowsConcentrations.shape[1]
        count=0
        for key in timeWindowsOccurences.keys():
            for j in range(1, columns):
                timeWindowsConcentrations[count,j]=int(timeWindowsConcentrations[count,j]/timeWindowsOccurences[key])
            count+=1
        return timeWindowsConcentrations

    def plotTraces(self, epsilon=0.5):
        """
        Plotting the traces with the epsilon time windows as its x-axis
        with the reaction frequencies for each time window.
        
        @param epsilon floating default epsilon is given but user can assign a new value.
        """
        data=self.concentrations
        originalTimeArray = data[:, 0]
        originalConcentrations = data[:, 1:]
        
        self.epsilonTimeArray = np.arange(originalTimeArray.min(), originalTimeArray.max() + epsilon, epsilon)
        timeWindows = self.generateTimeWindows()
        averageTimesArray= [self.getAverageTime(window) for window in timeWindows]
        timeWindowsConcentrations=self.getTimeWindowsConcentrations(originalTimeArray, averageTimesArray, timeWindows, originalConcentrations)
        reactionFrequencyData = self.reactionFrequenciesData()
        self.askForSubplot(timeWindowsConcentrations, reactionFrequencyData)
        
    def askForSubplot(self, concentrationData, reactionData, userInput=None):
        """
        Asking users for time range of the sub plot and plotting as many times as user requests new subplots.
        
        @param concentrationData int[][] molecular concentrations
        @param reactionData int[][] reactions data
        @param userInput str y or n as the user answer
        """
        
        if userInput is None:
            self.plot2Data(concentrationData, reactionData)
            userInput = input("Do you want to see a specific subplot? (Y/N): ")
        
        if userInput.lower() == 'y':
            minTime = int(input("Enter the minimum time: "))
            maxTime = int(input("Enter the maximum time: "))
            
            self.plot2Data(concentrationData, reactionData, timeRange=(minTime, maxTime))
            
            userInput = input("Do you want to see another specific subplot? (Y/N): ")
            self.askForSubplot(concentrationData, reactionData, userInput)
        else:
            userInput = input("Do you want to see a original plot again? (Y/N): ")
            if userInput.lower() == 'y':
                self.plot2Data(concentrationData, reactionData)
                userInput = input("Do you want to see a specific subplot? (Y/N): ")
                self.askForSubplot(concentrationData, reactionData, userInput)
            else:
                print("Terminating the plotting.")
    
    def askedForSpecificMoleculesPlot(self, data, moleculeIndex, labels):
        times=data[:, 0]
        moleculeCounts=data[:, moleculeIndex]
        if self.moleculeLabelsNotPlotted:
            if self.moleculeLabels[moleculeIndex-1] not in self.moleculeLabelsNotPlotted:
                plt.plot(times, moleculeCounts, color= self.colors[moleculeIndex-1], marker='o', label=labels[moleculeIndex-1])
        else:
            plt.plot(times, moleculeCounts, color= self.colors[moleculeIndex-1], marker='o', label=labels[moleculeIndex-1])
    
    def askedForReactionsPlot(self, data, reactionIndex, labels):
        times=data[:, 0]
        reactionCount=data[:, reactionIndex]
        plt.plot(times, reactionCount, color= self.colors[reactionIndex-1], marker='o', label=labels[reactionIndex-1])
        
    def plot2Data(self, concentrationData, reactionData, timeRange=None):
        reactionFrequency=reactionData[0]
        reactionLabels=reactionData[1]
        if timeRange:
            minTime, maxTime = timeRange
            
        numberOfColors=max(concentrationData.shape[1],len(reactionLabels))
        self.colors = sns.color_palette(cc.glasbey, n_colors=numberOfColors)
        for i in range(1, concentrationData.shape[1]):
            self.askedForSpecificMoleculesPlot(concentrationData, i, self.moleculeLabels)
        
        plt.xticks(self.epsilonTimeArray)
        plt.xlabel('Time')
        plt.ylabel('Data')
        plt.title(f'Molecule count ({minTime}-{maxTime})') if timeRange else plt.title('Molecule count')
        plt.grid(False)
        plt.xlim(minTime, maxTime) if timeRange else None
        plt.legend()
        plt.show()
        for j in range(1, reactionFrequency.shape[1]):
            self.askedForReactionsPlot(reactionFrequency, j, reactionLabels)
        
        plt.xticks(self.epsilonTimeArray)
        plt.xlabel('Time')
        plt.ylabel('Data')
        plt.title(f'Reaction frequency ({minTime}-{maxTime})') if timeRange else plt.title('Reaction frequency')
        plt.grid(False)
        plt.xlim(minTime, maxTime) if timeRange else None
        plt.legend()
        plt.tight_layout()
        plt.show()
        
    def generateTimeWindows(self):
        size = len(self.epsilonTimeArray)
        return [(self.epsilonTimeArray[i], self.epsilonTimeArray[i+1]) for i in range(size - 1)]
    
    def getAverageTime(self, window):
        return ((window[1]-window[0])/2+window[0])
    
    def searchWindowTuple(self, time, timeWindows):
        searchedWindow=None
        for window in timeWindows:
            if window[0] <= time <= window[1]:
                searchedWindow=window
                break
        return searchedWindow
    
    def initializeMoleculeLabels(self):
        """
        Initializing the initial molecule labels before traces by reading the input graphs
        """
        index=1
        for graph in self.inputGraphs:
            self.initialMoleculeLabels.append(str(index))
            index+=1

    def updateMoleculeLabels(self, moleculeLabels):
        """
        In case if some molecules are not occured in the traces, adding the missed molecule labels.
        The initial order of molecules and the order coming from traces are not the same.
        """
        if len(self.initialMoleculeLabels)==len(moleculeLabels):
            return moleculeLabels
        else:
            initial_set = set(self.initialMoleculeLabels)
            molecule_set = set(moleculeLabels)
            difference = initial_set - molecule_set
            moleculeLabels.extend(difference)
            '''
            difference = list(set(self.initialMoleculeLabels) - set(self.moleculeLabels))
            for item in difference:
                self.moleculeLabels.append(item)
            '''
            return moleculeLabels
            
    def defineTheHeaders(self, array, numberOfMolecules):
        """
        Defining the headers on the top of traces' concentration matrix
        
        @param array int[][] concentrations
        @param numberOfMolecules int total number of molecules in traces
        """
        headers = {"Trace time" : array[:,0]}
        for i in range(1, numberOfMolecules):
            header=self.moleculeLabels[i-1]
            headers[header]= array[:,i]
        return headers
    
    def storeAsCSV(self, array):
        """
        Storing the concentrations matrix as a csv file called result.csv
        
        @param array int[][] concentrations
        """
        numberOfMolecules = len(array[0])
        headers = self.defineTheHeaders(array, numberOfMolecules)
        data = pd.DataFrame(headers)
        data.to_csv("result.csv", index=False)
    
    def defineThreshold(self, data):
        """
        For the detection of global peaks and minimas, defining the threshold.
        
        @param  data    int[][]     concentration data
        """
        standardDeviation = np.std(data)
        threshold = standardDeviation
        return threshold
        
    def getGlobalPeaks(self, data):
        """
        Detection of global peaks in the concentration data.

        @param  data    int[][]     concentration data
        """

        prominenceThreshold= self.defineThreshold(data)
        peaks, _ = find_peaks(data, prominence=prominenceThreshold)
        return len(peaks) > 0
    
    def getGlobalMinimas(self, data):
        """
        Detection of global minimas in the concentration data,
        and returning boolean, checking there is more than 1 minima
        or not.
        The first one is the initial one and if we dont have the second
        or more, then the system is not oscilating.
        
        @param  data    int[][]     concentration data
        """

        prominenceThreshold = self.defineThreshold(data)
        minima, _ = find_peaks([-x for x in data], prominence=prominenceThreshold)
        minimaValues = [data[i] for i in minima]
        return sum(1 for element in minimaValues if element < 10) > 1
        
    def retrieveConcentrationInfoOverTime(self, traces, iMolecules, totalTime):
        """
        Retrieving the concentration information for every molecule
        in the traces over the time

        @iMolecules     int     total number of initial molecules in the system.
        """

        initialState = traces.initialState
        vertices = initialState.net.dg.vertices
        numVertices = initialState.net.dg.numVertices
        initialCounts= [0.0] * iMolecules
        for i in vertices:
            initialCounts[int(i.graph.name)]=initialState[i]

        numberOfStates = len(traces)  # Total number of states to track over time
        concentrations = np.zeros((numberOfStates, iMolecules + 1), dtype=np.float32)
        vertices = []
        for index, trace in enumerate(traces):
            vertices = []
            traceAction=trace.action
            if isinstance(traceAction, CausalityInputAction) or isinstance(traceAction, CausalityOutputAction):
                vertices = [traceAction.vertex]
            else:
                vertices = [next(iter(traceAction.edge.sources)), next(iter(traceAction.edge.targets))]
            trace.action.applyTo(initialState)  # Apply the action to the initialState
            for i in vertices: initialCounts[int(i.graph.name)]=initialState[i]
            concentrations[index, 0] = float(trace.time)  # Store the time in the first column
            molecule_concentrations = initialCounts
            if len(molecule_concentrations) < iMolecules:
                molecule_concentrations.extend([0] * (iMolecules - len(molecule_concentrations)))
            concentrations[index, 1:] = molecule_concentrations  # Store the molecule concentrations in the rest
        return concentrations
